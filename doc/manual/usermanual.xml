<?xml version="1.0"?>
<!--
  ex:ts=4:sw=4:sts=4:et
  -*- tab-width: 4; c-basic-offset: 4; indent-tabs-mode: nil -*-
-->
<!DOCTYPE book PUBLIC "-//OASIS//DTD DocBook XML V4.2//EN"
                      "http://www.oasis-open.org/docbook/xml/4.2/docbookx.dtd">
<book>
    <bookinfo>
        <title>BitBake User Manual</title>
        <authorgroup>
            <corpauthor>BitBake Team</corpauthor>
        </authorgroup>
        <copyright>
            <year>2004, 2005, 2006, 2011</year>
            <holder>Chris Larson</holder>
            <holder>Phil Blundell</holder>
            <holder>Richard Purdie</holder>
        </copyright>
        <legalnotice>
            <para>This work is licensed under the Creative Commons Attribution License. To view a copy of this license, visit <ulink url="http://creativecommons.org/licenses/by/2.5/">http://creativecommons.org/licenses/by/2.5/</ulink> or send a letter to Creative Commons, 559 Nathan Abbott Way, Stanford, California 94305, USA.</para>
        </legalnotice>
    </bookinfo>
    <chapter>
        <title>Introduction</title>
        <section>
            <title>Overview</title>
            <para>BitBake is, at its simplest, a tool for executing
tasks and managing metadata.  As such, its similarities to GNU make and other
build tools are readily apparent.  It was inspired by Portage, the package management system used by the Gentoo Linux distribution.  BitBake is the basis of the <ulink url="http://www.openembedded.org/">OpenEmbedded</ulink> project, which is being used to build and maintain a number of embedded Linux distributions/projects such as Angstrom and the Yocto project.</para>
        </section>
        <section>
            <title>Background and goals</title>
            <para>Prior to BitBake, no other build tool adequately met
the needs of an aspiring embedded Linux distribution.  All of the
buildsystems used by traditional desktop Linux distributions lacked
important functionality, and none of the ad-hoc
<emphasis>buildroot</emphasis> systems, prevalent in the
embedded space, were scalable or maintainable.</para>

      <para>Some important original goals for BitBake were:
            <itemizedlist>
                <listitem><para>Handle crosscompilation.</para></listitem>
                <listitem><para>Handle interpackage dependencies (build time on target architecture, build time on native architecture, and runtime).</para></listitem>
                <listitem><para>Support running any number of tasks within a given package, including, but not limited to, fetching upstream sources, unpacking them, patching them, configuring them, et cetera.</para></listitem>
                <listitem><para>Must be Linux distribution agnostic (both build and target).</para></listitem>
                <listitem><para>Must be architecture agnostic</para></listitem>
                <listitem><para>Must support multiple build and target operating systems (including Cygwin, the BSDs, etc).</para></listitem>
                <listitem><para>Must be able to be self contained, rather than tightly integrated into the build machine's root filesystem.</para></listitem>
                <listitem><para>There must be a way to handle conditional metadata (on target architecture, operating system, distribution, machine).</para></listitem>
                <listitem><para>It must be easy for the person using the tools to supply their own local metadata and packages to operate against.</para></listitem>
                <listitem><para>Must make it easy to collaborate
between multiple projects using BitBake for their
builds.</para></listitem>
		<listitem><para>Should provide an inheritance mechanism to
share common metadata between many packages.</para></listitem>
            </itemizedlist>
        </para>
        <para>Over time it has become apparent that some further requirements were necessary:
            <itemizedlist>
                <listitem><para>Handle variants of a base recipe (native, sdk, multilib).</para></listitem>
                <listitem><para>Able to split metadata into layers and allow layers to override each other.</para></listitem>
                <listitem><para>Allow representation of a given set of input variables to a task as a checksum.</para></listitem>
                <listitem><para>based on that checksum, allow acceleration of builds with prebuilt components.</para></listitem>
            </itemizedlist>
        </para>

        <para>BitBake satisfies all the original requirements and many more with extensions being made to the basic functionality to reflect the additionl requirements.  Flexibility and power have always been the priorities.  It is highly extensible, supporting embedded Python code and execution of any arbitrary tasks.</para>
        </section>
    </chapter>
    <chapter>
        <title>Metadata</title>
        <section>
            <title>Description</title>
            <itemizedlist>
                <para>BitBake metadata can be classified into 3 major areas:</para>
                <listitem>
                    <para>Configuration Files</para>
                </listitem>
                <listitem>
                    <para>.bb Files</para>
                </listitem>
                <listitem>
                    <para>Classes</para>
                </listitem>
            </itemizedlist>
            <para>What follows are a large number of examples of BitBake metadata.  Any syntax which isn't supported in any of the aforementioned areas will be documented as such.</para>
            <section>
                <title>Basic variable setting</title>
                <para><screen><varname>VARIABLE</varname> = "value"</screen></para>
                <para>In this example, <varname>VARIABLE</varname> is <literal>value</literal>.</para>
            </section>
            <section>
                <title>Variable expansion</title>
                <para>BitBake supports variables referencing one another's contents using a syntax which is similar to shell scripting</para>
                <para><screen><varname>A</varname> = "aval"
<varname>B</varname> = "pre${A}post"</screen></para>
                <para>This results in <varname>A</varname> containing <literal>aval</literal> and <varname>B</varname> containing <literal>preavalpost</literal>.</para>
            </section>
            <section>
                <title>Setting a default value (?=)</title>
                <para><screen><varname>A</varname> ?= "aval"</screen></para>
                <para>If <varname>A</varname> is set before the above is called, it will retain its previous value. If <varname>A</varname> is unset prior to the above call, <varname>A</varname> will be set to <literal>aval</literal>.  Note that this assignment is immediate, so if there are multiple ?= assignments to a single variable, the first of those will be used.</para>
            </section>
            <section>
                <title>Setting a weak default value (??=)</title>
                <para><screen><varname>A</varname> ??= "somevalue"
<varname>A</varname> ??= "someothervalue"</screen></para>
                <para>If <varname>A</varname> is set before the above, it will retain that value.  If <varname>A</varname> is unset prior to the above, <varname>A</varname> will be set to <literal>someothervalue</literal>.  This is a lazy/weak assignment in that the assignment does not occur until the end of the parsing process, so that the last, rather than the first, ??= assignment to a given variable will be used. Any other setting of A using = or ?= will however override the value set with ??=</para>
            </section>
            <section>
                <title>Immediate variable expansion (:=)</title>
                <para>:= results in a variable's contents being expanded immediately, rather than when the variable is actually used.</para>
                <para><screen><varname>T</varname> = "123"
<varname>A</varname> := "${B} ${A} test ${T}"
<varname>T</varname> = "456"
<varname>B</varname> = "${T} bval"

<varname>C</varname> = "cval"
<varname>C</varname> := "${C}append"</screen></para>
                <para>In that example, <varname>A</varname> would contain <literal> test 123</literal>, <varname>B</varname> would contain <literal>456 bval</literal>, and <varname>C</varname> would be <literal>cvalappend</literal>.</para>
            </section>
            <section>
                <title>Appending (+=) and prepending (=+)</title>
                <para><screen><varname>B</varname> = "bval"
<varname>B</varname> += "additionaldata"
<varname>C</varname> = "cval"
<varname>C</varname> =+ "test"</screen></para>
                <para>In this example, <varname>B</varname> is now <literal>bval additionaldata</literal> and <varname>C</varname> is <literal>test cval</literal>.</para>
            </section>
            <section>
                <title>Appending (.=) and prepending (=.) without spaces</title>
                    <para><screen><varname>B</varname> = "bval"
<varname>B</varname> .= "additionaldata"
<varname>C</varname> = "cval"
<varname>C</varname> =. "test"</screen></para>
                <para>In this example, <varname>B</varname> is now <literal>bvaladditionaldata</literal> and <varname>C</varname> is <literal>testcval</literal>. In contrast to the above appending and prepending operators, no additional space
will be introduced.</para>
            </section>
            <section>
                <title>Conditional metadata set</title>
                <para>OVERRIDES is a <quote>:</quote> separated variable containing each item you want to satisfy conditions.  So, if you have a variable which is conditional on <quote>arm</quote>, and <quote>arm</quote> is in OVERRIDES, then the <quote>arm</quote> specific version of the variable is used rather than the non-conditional version.  Example:</para>
                <para><screen><varname>OVERRIDES</varname> = "architecture:os:machine"
<varname>TEST</varname> = "defaultvalue"
<varname>TEST_os</varname> = "osspecificvalue"
<varname>TEST_condnotinoverrides</varname> = "othercondvalue"</screen></para>
                <para>In this example, <varname>TEST</varname> would be <literal>osspecificvalue</literal>, due to the condition <quote>os</quote> being in <varname>OVERRIDES</varname>.</para>
            </section>
            <section>
                <title>Conditional appending</title>
                <para>BitBake also supports appending and prepending to variables based on whether something is in OVERRIDES.  Example:</para>
                <para><screen><varname>DEPENDS</varname> = "glibc ncurses"
<varname>OVERRIDES</varname> = "machine:local"
<varname>DEPENDS_append_machine</varname> = " libmad"</screen></para>
                <para>In this example, <varname>DEPENDS</varname> is set to <literal>glibc ncurses libmad</literal>.</para>
            </section>
            <section>
                <title>Inclusion</title>
                <para>Next, there is the <literal>include</literal> directive, which causes BitBake to parse whatever file you specify, and insert it at that location, which is not unlike <command>make</command>.  However, if the path specified on the <literal>include</literal> line is a relative path, BitBake will locate the first one it can find within <envar>BBPATH</envar>.</para>
            </section>
            <section>
                <title>Requiring inclusion</title>
                <para>In contrast to the <literal>include</literal> directive, <literal>require</literal> will
raise an ParseError if the file to be included cannot be found. Otherwise it will behave just like the <literal>
include</literal> directive.</para>
            </section>
            <section>
                <title>Python variable expansion</title>
                <para><screen><varname>DATE</varname> = "${@time.strftime('%Y%m%d',time.gmtime())}"</screen></para>
                <para>This would result in the <varname>DATE</varname> variable containing today's date.</para>
            </section>
            <section>
                <title>Defining executable metadata</title>
                <para><emphasis>NOTE:</emphasis> This is only supported in .bb and .bbclass files.</para>
                <para><screen>do_mytask () {
    echo "Hello, world!"
}</screen></para>
                <para>This is essentially identical to setting a variable, except that this variable happens to be executable shell code.</para>
                <para><screen>python do_printdate () {
    import time
    print time.strftime('%Y%m%d', time.gmtime())
}</screen></para>
                <para>This is the similar to the previous, but flags it as Python so that BitBake knows it is Python code.</para>
            </section>
            <section>
                <title>Defining Python functions into the global Python namespace</title>
                <para><emphasis>NOTE:</emphasis> This is only supported in .bb and .bbclass files.</para>
                <para><screen>def get_depends(bb, d):
    if bb.data.getVar('SOMECONDITION', d, True):
        return "dependencywithcond"
    else:
        return "dependency"

<varname>SOMECONDITION</varname> = "1"
<varname>DEPENDS</varname> = "${@get_depends(bb, d)}"</screen></para>
                <para>This would result in <varname>DEPENDS</varname> containing <literal>dependencywithcond</literal>.</para>
            </section>
            <section>
                <title>Variable flags</title>
                <para>Variables can have associated flags which provide a way of tagging extra information onto a variable. Several flags are used internally by BitBake but they can be used externally too if needed. The standard operations mentioned above also work on flags.</para>
                <para><screen><varname>VARIABLE</varname>[<varname>SOMEFLAG</varname>] = "value"</screen></para>
                <para>In this example, <varname>VARIABLE</varname> has a flag, <varname>SOMEFLAG</varname> which is set to <literal>value</literal>.</para>
            </section>
            <section>
                <title>Inheritance</title>
                <para><emphasis>NOTE:</emphasis> This is only supported in .bb and .bbclass files.</para>
                <para>The <literal>inherit</literal> directive is a means of specifying what classes of functionality your .bb requires.  It is a rudimentary form of inheritance.  For example, you can easily abstract out the tasks involved in building a package that uses autoconf and automake, and put that into a bbclass for your packages to make use of.  A given bbclass is located by searching for classes/filename.oeclass in <envar>BBPATH</envar>, where filename is what you inherited.</para>
            </section>
            <section>
                <title>Tasks</title>
                <para><emphasis>NOTE:</emphasis> This is only supported in .bb and .bbclass files.</para>
                <para>In BitBake, each step that needs to be run for a given .bb is known as a task.  There is a command <literal>addtask</literal> to add new tasks (must be a defined Python executable metadata and must start with <quote>do_</quote>) and describe intertask dependencies.</para>
                <para><screen>python do_printdate () {
    import time
    print time.strftime('%Y%m%d', time.gmtime())
}

addtask printdate before do_build</screen></para>
                <para>This defines the necessary Python function and adds it as a task which is now a dependency of do_build, the default task.  If anyone executes the do_build task, that will result in do_printdate being run first.</para>
            </section>

            <section>
                <title>Task Flags</title>
                <para>Tasks support a number of flags which control various functionality of the task. These are as follows:</para>
                <para>'dirs' - directories which should be created before the task runs</para>
                <para>'cleandirs' - directories which should created before the task runs but should be empty</para>
                <para>'noexec' - marks the tasks as being empty and no execution required. These are used as dependency placeholders or used when added tasks need to be subsequently disabled.</para>
                <para>'nostamp' - don't generate a stamp file for a task. This means the task is always rexecuted.</para>
                <para>'fakeroot' - this task needs to be run in a fakeroot environment, obtained by adding the variables in FAKEROOTENV to the environment.</para>
                <para>'umask' - the umask to run the task under.</para>
                <para> For the 'deptask', 'rdeptask', 'recdeptask' and 'recrdeptask' flags please see the dependencies section.</para>
            </section>

            <section>
                <title>Events</title>
                <para><emphasis>NOTE:</emphasis> This is only supported in .bb and .bbclass files.</para>
                <para>BitBake allows installation of event handlers.  Events are triggered at certain points during operation, such as the beginning of operation against a given .bb, the start of a given task, task failure, task success, et cetera.  The intent is to make it easy to do things like email notification on build failure.</para>
                <para><screen>addhandler myclass_eventhandler
python myclass_eventhandler() {
    from bb.event import getName
    from bb import data

    print("The name of the Event is %s" % getName(e))
    print("The file we run for is %s" % data.getVar('FILE', e.data, True))
}
</screen></para><para>
This event handler gets called every time an event is triggered. A global variable <varname>e</varname> is defined. <varname>e</varname>.data contains an instance of bb.data. With the getName(<varname>e</varname>)
method one can get the name of the triggered event.</para><para>The above event handler prints the name
of the event and the content of the <varname>FILE</varname> variable.</para>
            </section>
            <section>
                <title>Variants</title>
                <para>Two BitBake features exist to facilitate the creation of multiple buildable incarnations from a single recipe file.</para>
                <para>The first is <varname>BBCLASSEXTEND</varname>.  This variable is a space separated list of classes used to "extend" the recipe for each variant.  As an example, setting <screen>BBCLASSEXTEND = "native"</screen> results in a second incarnation of the current recipe being available.  This second incarantion will have the "native" class inherited.</para>
                <para>The second feature is <varname>BBVERSIONS</varname>.  This variable allows a single recipe to build multiple versions of a project from a single recipe file, and allows you to specify conditional metadata (using the <varname>OVERRIDES</varname> mechanism) for a single version, or an optionally named range of versions:</para>
                <para><screen>BBVERSIONS = "1.0 2.0 git"
SRC_URI_git = "git://someurl/somepath.git"</screen></para>
                <para><screen>BBVERSIONS = "1.0.[0-6]:1.0.0+ \
              1.0.[7-9]:1.0.7+"
SRC_URI_append_1.0.7+ = "file://some_patch_which_the_new_versions_need.patch;patch=1"</screen></para>
                <para>Note that the name of the range will default to the original version of the recipe, so given OE, a recipe file of foo_1.0.0+.bb will default the name of its versions to 1.0.0+.  This is useful, as the range name is not only placed into overrides; it's also made available for the metadata to use in the form of the <varname>BPV</varname> variable, for use in file:// search paths (<varname>FILESPATH</varname>).</para>
            </section>
        </section>

        <section>
            <title>Variable interaction: Worked Examples</title>
            <para>Despite the documentation of the different forms of variable definition above, it can be hard to work out what happens when variable operators are combined. This section documents some common questions people have regarding the way variables interact.</para>

            <section>
                <title>Override and append ordering</title>

                <para>There is often confusion about which order overrides and the various append operators take effect.</para>

                <para><screen><varname>OVERRIDES</varname> = "foo"
<varname>A_foo_append</varname> = "X"</screen></para>
                <para>In this case, X is unconditionally appended to the variable <varname>A_foo</varname>. Since foo is an override, A_foo would then replace <varname>A</varname>.</para>

                 <para><screen><varname>OVERRIDES</varname> = "foo"
<varname>A</varname> = "X"
<varname>A_append_foo</varname> = "Y"</screen></para>
                <para>In this case, only when foo is in OVERRIDES, Y is appended to the variable <varname>A</varname> so the value of <varname>A</varname> would become XY (NB: no spaces are appended).</para>

                <para><screen><varname>OVERRIDES</varname> = "foo"
<varname>A_foo_append</varname> = "X"
<varname>A_foo_append</varname> += "Y"</screen></para>
                <para>This behaves as per the first case above, but the value of <varname>A</varname> would be "X Y" instead of just "X".</para>

                <para><screen><varname>A</varname> = "1"
<varname>A_append</varname> = "2"
<varname>A_append</varname> = "3"
<varname>A</varname> += "4"
<varname>A</varname> .= "5"</screen></para>

                <para>Would ultimately result in <varname>A</varname> taking the value "1 4523" since the _append operator executes at the same time as the expansion of other overrides.</para>

            </section>
            <section>
                <title>Key Expansion</title>

                <para>Key expansion happens at the data store finalisation time just before overrides are expanded.</para>

                <para><screen><varname>A${B}</varname> = "X"
<varname>B</varname> = "2"
<varname>A2</varname> = "Y"</screen></para>
                <para>So in this case <varname>A2</varname> would take the value of "X".</para>
            </section>

        </section>
        <section>
            <title>Dependency handling</title>
            <para>BitBake 1.7.x onwards works with the metadata at the task level since this is optimal when dealing with multiple threads of execution. A robust method of specifing task dependencies is therefore needed. </para>
            <section>
                <title>Dependencies internal to the .bb file</title>
                <para>Where the dependencies are internal to a given .bb file, the dependencies are handled by the previously detailed addtask directive.</para>
            </section>

            <section>
                <title>DEPENDS</title>
                <para>DEPENDS lists build time dependencies. The 'deptask' flag for tasks is used to signify the task of each item listed in DEPENDS which must have completed before that task can be executed.</para>
                <para><screen>do_configure[deptask] = "do_populate_staging"</screen></para>
                <para>means the do_populate_staging task of each item in DEPENDS must have completed before do_configure can execute.</para>
            </section>
            <section>
                <title>RDEPENDS</title>
                <para>RDEPENDS lists runtime dependencies. The 'rdeptask' flag for tasks is used to signify the task of each item listed in RDEPENDS which must have completed before that task can be executed.</para>
                <para><screen>do_package_write[rdeptask] = "do_package"</screen></para>
                <para>means the do_package task of each item in RDEPENDS must have completed before do_package_write can execute.</para>
            </section>
            <section>
                <title>Recursive DEPENDS</title>
                <para>These are specified with the 'recdeptask' flag and is used signify the task(s) of each DEPENDS which must have completed before that task can be executed. It applies recursively so the DEPENDS of each item in the original DEPENDS must be met and so on.</para>
            </section>
            <section>
                <title>Recursive RDEPENDS</title>
                <para>These are specified with the 'recrdeptask' flag and is used signify the task(s) of each RDEPENDS which must have completed before that task can be executed. It applies recursively so the RDEPENDS of each item in the original RDEPENDS must be met and so on. It also runs all DEPENDS first.</para>
            </section>
            <section>
                <title>Inter task</title>
                <para>The 'depends' flag for tasks is a more generic form of which allows an interdependency on specific tasks rather than specifying the data in DEPENDS or RDEPENDS.</para>
                <para><screen>do_patch[depends] = "quilt-native:do_populate_staging"</screen></para>
                <para>means the do_populate_staging task of the target quilt-native must have completed before the do_patch can execute.</para>
            </section>
        </section>

        <section>
            <title>Parsing</title>
            <section>
                <title>Configuration files</title>
                <para>The first kind of metadata in BitBake is configuration metadata.  This metadata is global, and therefore affects <emphasis>all</emphasis> packages and tasks which are executed.</para>
                <para>BitBake will first search the current working directory for an optional "conf/bblayers.conf" configuration file. This file is expected to contain a BBLAYERS variable which is a space delimited list of 'layer' directories. For each directory in this list, a "conf/layer.conf" file will be searched for and parsed with the LAYERDIR variable being set to the directory where the layer was found. The idea is these files will setup BBPATH and other variables correctly for a given build directory automatically for the user.</para>
                <para>BitBake will then expect to find 'conf/bitbake.conf' somewhere in the user specified <envar>BBPATH</envar>.  That configuration file generally has include directives to pull in any other metadata (generally files specific to architecture, machine, <emphasis>local</emphasis> and so on).</para>
                <para>Only variable definitions and include directives are allowed in .conf files.</para>
            </section>
            <section>
                <title>Classes</title>
                <para>BitBake classes are our rudimentary inheritance mechanism.  As briefly mentioned in the metadata introduction, they're parsed when an <literal>inherit</literal> directive is encountered, and they are located in classes/ relative to the directories in <envar>BBPATH</envar>.</para>
            </section>
            <section>
                <title>.bb files</title>
                <para>A BitBake (.bb) file is a logical unit of tasks to be executed.  Normally this is a package to be built.  Inter-.bb dependencies are obeyed.  The files themselves are located via the <varname>BBFILES</varname> variable, which is set to a space separated list of .bb files, and does handle wildcards.</para>
            </section>
        </section>
    </chapter>

    <chapter>
        <title>File download support</title>
        <section>
            <title>Overview</title>
            <para>BitBake provides support to download files this procedure is called fetching and it handled by the fetch and fetch2 modules. At this point the original fetch code is considered to be replaced by fetch2 and this manual only related to the fetch2 codebase.</para>

            <para>The SRC_URI is normally used to tell BitBake which files to fetch. The next sections will describe the available fetchers and their options. Each fetcher honors a set of variables and per URI parameters separated by a <quote>;</quote> consisting of a key and a value. The semantics of the variables and parameters are defined by the fetcher. BitBake tries to have consistent semantics between the different fetchers.
            </para>

            <para>The overall fetch process is that first, fetches are attempted from PREMIRRORS. If those don't work, the original SRC_URI is attempted and if that fails, BitBake will fall back to MIRRORS. Cross urls are supported, so its possible to mirror a git repository on an http server as a tarball for example. Some example commonly used mirror definitions are:</para>

            <para><screen><varname>PREMIRRORS</varname> ?= "\
bzr://.*/.*   http://somemirror.org/sources/ \n \
cvs://.*/.*   http://somemirror.org/sources/ \n \
git://.*/.*   http://somemirror.org/sources/ \n \
hg://.*/.*    http://somemirror.org/sources/ \n \
osc://.*/.*   http://somemirror.org/sources/ \n \
p4://.*/.*    http://somemirror.org/sources/ \n \
svk://.*/.*   http://somemirror.org/sources/ \n \
svn://.*/.*   http://somemirror.org/sources/ \n"

<varname>MIRRORS</varname> =+ "\
ftp://.*/.*      http://somemirror.org/sources/ \n \
http://.*/.*     http://somemirror.org/sources/ \n \
https://.*/.*    http://somemirror.org/sources/ \n"</screen></para>

            <para>Non-local downloaded output is placed into the directory specified by the <varname>DL_DIR</varname>. For non local downloads the code can check checksums for the download to ensure the file has been downloaded correctly. These are specified in the form <varname>SRC_URI[md5sum]</varname> for the md5 checksum and <varname>SRC_URI[sha256sum]</varname> for the sha256 checksum. If <varname>BB_STRICT_CHECKSUM</varname> is set, any download without a checksum will trigger an error message. In cases where multiple files are listed in SRC_URI, the name parameter is used assign names to the urls and these are then specified in the checksums in the form SRC_URI[name.sha256sum].</para>

        </section>

        <section>
            <title>Local file fetcher</title>
            <para>The URN for the local file fetcher is <emphasis>file</emphasis>. The filename can be either absolute or relative. If the filename is relative, <varname>FILESPATH</varname> and failing that <varname>FILESDIR</varname> will be used to find the appropriate relative file. The metadata usually extend these variables to include variations of the values in <varname>OVERRIDES</varname>. Single files and complete directories can be specified.
<screen><varname>SRC_URI</varname>= "file://relativefile.patch"
<varname>SRC_URI</varname>= "file://relativefile.patch;this=ignored"
<varname>SRC_URI</varname>= "file:///Users/ich/very_important_software"
</screen>
            </para>
        </section>

        <section>
            <title>CVS fetcher</title>
            <para>The URN for the CVS fetcher is <emphasis>cvs</emphasis>. This fetcher honors the variables <varname>CVSDIR</varname>, <varname>SRCDATE</varname>, <varname>FETCHCOMMAND_cvs</varname>, <varname>UPDATECOMMAND_cvs</varname>. <varname>DL_DIR</varname> specifies where a temporary checkout is saved. <varname>SRCDATE</varname> specifies which date to use when doing the fetching (the special value of "now" will cause the checkout to be updated on every build). <varname>FETCHCOMMAND</varname> and <varname>UPDATECOMMAND</varname> specify which executables to use for the CVS checkout or update.
            </para>
            <para>The supported parameters are <varname>module</varname>, <varname>tag</varname>, <varname>date</varname>, <varname>method</varname>, <varname>localdir</varname>, <varname>rsh</varname> and <varname>scmdata</varname>. The <varname>module</varname> specifies which module to check out, the <varname>tag</varname> describes which CVS TAG should be used for the checkout. By default the TAG is empty. A <varname>date</varname> can be specified to override the SRCDATE of the configuration to checkout a specific date.  The special value of "now" will cause the checkout to be updated on every build.<varname>method</varname> is by default <emphasis>pserver</emphasis>. If <emphasis>ext</emphasis> is used the <varname>rsh</varname> parameter will be evaluated and <varname>CVS_RSH</varname> will be set. Finally, <varname>localdir</varname> is used to checkout into a special directory relative to <varname>CVSDIR</varname>.

<screen><varname>SRC_URI</varname> = "cvs://CVSROOT;module=mymodule;tag=some-version;method=ext"
<varname>SRC_URI</varname> = "cvs://CVSROOT;module=mymodule;date=20060126;localdir=usethat"
</screen>
            </para>
        </section>

        <section>
            <title>HTTP/FTP fetcher</title>
            <para>The URNs for the HTTP/FTP fetcher are <emphasis>http</emphasis>, <emphasis>https</emphasis> and <emphasis>ftp</emphasis>. This fetcher honors the variables <varname>FETCHCOMMAND_wget</varname>. <varname>FETCHCOMMAND</varname> contains the command used for fetching. <quote>${URI}</quote> and <quote>${FILES}</quote> will be replaced by the URI and basename of the file to be fetched.
            </para>
            <para><screen><varname>SRC_URI</varname> = "http://oe.handhelds.org/not_there.aac"
<varname>SRC_URI</varname> = "ftp://oe.handhelds.org/not_there_as_well.aac"
<varname>SRC_URI</varname> = "ftp://you@oe.handheld.sorg/home/you/secret.plan"
</screen></para>
        </section>

        <section>
            <title>SVN fetcher</title>
            <para>The URN for the SVN fetcher is <emphasis>svn</emphasis>.
            </para>
            <para>This fetcher honors the variables <varname>FETCHCOMMAND_svn</varname>, <varname>SVNDIR</varname>, <varname>SRCREV</varname>. <varname>FETCHCOMMAND</varname> contains the subversion command. <varname>SRCREV</varname> specifies which revision to use when doing the fetching.
            </para>
            <para>The supported parameters are <varname>proto</varname>, <varname>rev</varname> and <varname>scmdata</varname>. <varname>proto</varname> is the Subversion protocol, <varname>rev</varname> is the Subversion revision. If <varname>scmdata</varname> is set to <quote>keep</quote>, the <quote>.svn</quote> directories will be available during compile-time.
            </para>
            <para><screen><varname>SRC_URI</varname> = "svn://svn.oe.handhelds.org/svn;module=vip;proto=http;rev=667"
<varname>SRC_URI</varname> = "svn://svn.oe.handhelds.org/svn/;module=opie;proto=svn+ssh;date=20060126"
</screen></para>
        </section>

        <section>
            <title>GIT fetcher</title>
            <para>The URN for the GIT Fetcher is <emphasis>git</emphasis>.
            </para>
            <para>The variable <varname>GITDIR</varname> will be used as the base directory where the git tree is cloned to.
            </para>
            <para>The parameters are <emphasis>tag</emphasis>, <emphasis>protocol</emphasis> and <emphasis>scmdata</emphasis>. <emphasis>tag</emphasis> is a Git tag, the default is <quote>master</quote>. <emphasis>protocol</emphasis> is the Git protocol to use and defaults to <quote>git</quote> if a hostname is set, otherwise its <quote>file</quote>. If <emphasis>scmdata</emphasis> is set to <quote>keep</quote>, the <quote>.git</quote> directory will be available during compile-time.
            </para>
            <para><screen><varname>SRC_URI</varname> = "git://git.oe.handhelds.org/git/vip.git;tag=version-1"
<varname>SRC_URI</varname> = "git://git.oe.handhelds.org/git/vip.git;protocol=http"
            </screen></para>
        </section>

    </chapter>


    <chapter>
        <title>The BitBake command</title>
            <section>
                <title>Introduction</title>
                <para>bitbake is the primary command in the system.  It facilitates executing tasks in a single .bb file, or executing a given task on a set of multiple .bb files, accounting for interdependencies amongst them.</para>
            </section>
            <section>
                <title>Usage and syntax</title>
                <para>
                    <screen><prompt>$ </prompt>bitbake --help
usage: bitbake [options] [package ...]

Executes the specified task (default is 'build') for a given set of BitBake files.
It expects that BBFILES is defined, which is a space separated list of files to
be executed.  BBFILES does support wildcards.
Default BBFILES are the .bb files in the current directory.

options:
  --version             show program's version number and exit
  -h, --help            show this help message and exit
  -b BUILDFILE, --buildfile=BUILDFILE
                        execute the task against this .bb file, rather than a
                        package from BBFILES.
  -k, --continue        continue as much as possible after an error. While the
                        target that failed, and those that depend on it,
                        cannot be remade, the other dependencies of these
                        targets can be processed all the same.
  -f, --force           force run of specified cmd, regardless of stamp status
  -i, --interactive     drop into the interactive mode also called the BitBake
                        shell.
  -c CMD, --cmd=CMD     Specify task to execute. Note that this only executes
                        the specified task for the providee and the packages
                        it depends on, i.e. 'compile' does not implicitly call
                        stage for the dependencies (IOW: use only if you know
                        what you are doing). Depending on the base.bbclass a
                        listtasks task is defined and will show available
                        tasks
  -r FILE, --read=FILE  read the specified file before bitbake.conf
  -v, --verbose         output more chit-chat to the terminal
  -D, --debug           Increase the debug level. You can specify this more
                        than once.
  -n, --dry-run         don't execute, just go through the motions
  -p, --parse-only      quit after parsing the BB files (developers only)
  -s, --show-versions   show current and preferred versions of all packages
  -e, --environment     show the global or per-package environment (this is
                        what used to be bbread)
  -g, --graphviz        emit the dependency trees of the specified packages in
                        the dot syntax
  -I IGNORED_DOT_DEPS, --ignore-deps=IGNORED_DOT_DEPS
                        Stop processing at the given list of dependencies when
                        generating dependency graphs. This can help to make
                        the graph more appealing
  -l DEBUG_DOMAINS, --log-domains=DEBUG_DOMAINS
                        Show debug logging for the specified logging domains
  -P, --profile         profile the command and print a report


</screen>
                </para>
                <para>
                <example>
                    <title>Executing a task against a single .bb</title>
                    <para>Executing tasks for a single file is relatively simple.  You specify the file in question, and BitBake parses it and executes the specified task (or <quote>build</quote> by default).  It obeys intertask dependencies when doing so.</para>
                    <para><quote>clean</quote> task:</para>
                    <para><screen><prompt>$ </prompt>bitbake -b blah_1.0.bb -c clean</screen></para>
                    <para><quote>build</quote> task:</para>
                    <para><screen><prompt>$ </prompt>bitbake -b blah_1.0.bb</screen></para>
                </example>
                </para>
                <para>
                <example>
                    <title>Executing tasks against a set of .bb files</title>
                    <para>There are a number of additional complexities introduced when one wants to manage multiple .bb files.  Clearly there needs to be a way to tell BitBake what files are available, and of those, which we want to execute at this time.  There also needs to be a way for each .bb to express its dependencies, both for build time and runtime.  There must be a way for the user to express their preferences when multiple .bb's provide the same functionality, or when there are multiple versions of a .bb.</para>
                    <para>The next section, Metadata, outlines how to specify such things.</para>
                    <para>Note that the bitbake command, when not using --buildfile, accepts a <varname>PROVIDER</varname>, not a filename or anything else.  By default, a .bb generally PROVIDES its packagename, packagename-version, and packagename-version-revision.</para>
                    <screen><prompt>$ </prompt>bitbake blah</screen>
                    <screen><prompt>$ </prompt>bitbake blah-1.0</screen>
                    <screen><prompt>$ </prompt>bitbake blah-1.0-r0</screen>
                    <screen><prompt>$ </prompt>bitbake -c clean blah</screen>
                    <screen><prompt>$ </prompt>bitbake virtual/whatever</screen>
                    <screen><prompt>$ </prompt>bitbake -c clean virtual/whatever</screen>
                </example>
                <example>
                    <title>Generating dependency graphs</title>
                    <para>BitBake is able to generate dependency graphs using the dot syntax. These graphs can be converted
to images using the <application>dot</application> application from <ulink url="http://www.graphviz.org">Graphviz</ulink>. 
Two files will be written into the current working directory, <emphasis>depends.dot</emphasis> containing dependency information at the package level and <emphasis>task-depends.dot</emphasis> containing a breakdown of the dependencies at the task level. To stop depending on common depends, one can use the <prompt>-I depend</prompt> to omit these from the graph. This can lead to more readable graphs.  This way, <varname>DEPENDS</varname> from inherited classes such as base.bbclass can be removed from the graph.</para>
                    <screen><prompt>$ </prompt>bitbake -g blah</screen>
                    <screen><prompt>$ </prompt>bitbake -g -I virtual/whatever -I bloom blah</screen>
                </example>
                </para>
            </section>
            <section>
                <title>Special variables</title>
                <para>Certain variables affect BitBake operation:</para>
                <section>
                    <title><varname>BB_NUMBER_THREADS</varname></title>
                    <para> The number of threads BitBake should run at once (default: 1).</para>
                </section>
            </section>
            <section>
                <title>Metadata</title>
                <para>As you may have seen in the usage information, or in the information about .bb files, the <varname>BBFILES</varname> variable is how the BitBake tool locates its files.  This variable is a space separated list of files that are available, and supports wildcards.
                <example>
                    <title>Setting BBFILES</title>
                    <programlisting><varname>BBFILES</varname> = "/path/to/bbfiles/*.bb"</programlisting>
                </example></para>
                <para>With regard to dependencies, it expects the .bb to define a <varname>DEPENDS</varname> variable, which contains a space separated list of <quote>package names</quote>, which themselves are the <varname>PN</varname> variable.  The <varname>PN</varname> variable is, in general, set to a component of the .bb filename by default.</para>
                <example>
                    <title>Depending on another .bb</title>
                    <para>a.bb:
    <screen>PN = "package-a"
DEPENDS += "package-b"</screen>
                    </para>
                    <para>b.bb:
    <screen>PN = "package-b"</screen>
                    </para>
                </example>
                <example>
                    <title>Using PROVIDES</title>
                    <para>This example shows the usage of the <varname>PROVIDES</varname> variable, which allows a given .bb to specify what functionality it provides.</para>
                    <para>package1.bb:
    <screen>PROVIDES += "virtual/package"</screen>
                    </para>
                    <para>package2.bb:
    <screen>DEPENDS += "virtual/package"</screen>
                    </para>
                    <para>package3.bb:
    <screen>PROVIDES += "virtual/package"</screen>
                    </para>
                    <para>As you can see, we have two different .bb's that provide the same functionality (virtual/package).  Clearly, there needs to be a way for the person running BitBake to control which of those providers gets used.  There is, indeed, such a way.</para>
                    <para>The following would go into a .conf file, to select package1:
    <screen>PREFERRED_PROVIDER_virtual/package = "package1"</screen>
                    </para>
                </example>
                <example>
                    <title>Specifying version preference</title>
                    <para>When there are multiple <quote>versions</quote> of a given package, BitBake defaults to selecting the most recent version, unless otherwise specified.  If the .bb in question has a <varname>DEFAULT_PREFERENCE</varname> set lower than the other .bb's (default is 0), then it will not be selected.  This allows the person or persons maintaining the repository of .bb files to specify their preference for the default selected version.  In addition, the user can specify their preferred version.</para>
                    <para>If the first .bb is named <filename>a_1.1.bb</filename>, then the <varname>PN</varname> variable will be set to <quote>a</quote>, and the <varname>PV</varname> variable will be set to 1.1.</para>
                    <para>If we then have an <filename>a_1.2.bb</filename>, BitBake will choose 1.2 by default.  However, if we define the following variable in a .conf that BitBake parses, we can change that.
    <screen>PREFERRED_VERSION_a = "1.1"</screen>
                    </para>
                </example>
                <example>
                    <title>Using <quote>bbfile collections</quote></title>
                    <para>bbfile collections exist to allow the user to have multiple repositories of bbfiles that contain the same exact package.  For example, one could easily use them to make one's own local copy of an upstream repository, but with custom modifications that one does not want upstream.  Usage:</para>
                    <screen>BBFILES = "/stuff/openembedded/*/*.bb /stuff/openembedded.modified/*/*.bb"
BBFILE_COLLECTIONS = "upstream local"
BBFILE_PATTERN_upstream = "^/stuff/openembedded/"
BBFILE_PATTERN_local = "^/stuff/openembedded.modified/"
BBFILE_PRIORITY_upstream = "5"
BBFILE_PRIORITY_local = "10"</screen>
                </example>
            </section>
    </chapter>
</book>
